

class TestWriteMetaDataIfDifferent(unittest.TestCase):

    def test_no_change(self):
        with tempfile.TemporaryDirectory() as d:
            version_vector = {'A': 17}
            file_hashes = {'diary': 'hash of entries'}
            ts = {
                'path': os.path.join(d, 'non', 'existent'),
                'id': 'MyTree',
                'pre_vv': version_vector,
                'known_hashes': file_hashes,
                'disk_hashes': {'shopping list': 'hash of food names'},
                'post_vv': {'B': 3},
            }
            file_ops.write_meta_data_if_different(
                version_vector, file_hashes, ts)

    def test_change(self):
        with tempfile.TemporaryDirectory() as d:
            md_path = os.path.join(d, file_ops.META_FILE)
            def get_old_md():
                return {
                    'id': 'MyDir',
                    'file_hashes': {'diary': 'hash of entries'},
                    'version_vector': {'A': 2},
                }
            file_ops.write_meta_data(get_old_md(), md_path)

            def get_ts():
                return {
                    'path': d,
                    'id': get_old_md()['id'],
                    'pre_vv': get_old_md()['version_vector'],
                    'known_hashes': get_old_md()['file_hashes'],
                    'disk_hashes': {},
                    'post_vv': {},
                }
            def get_new_md():
                return {
                    'id': 'MyDir',
                    'file_hashes': {'documents': 'hash of text'},
                    'version_vector': {'Z': 12},
                }

            file_ops.write_meta_data_if_different(
                get_new_md()['version_vector'],
                get_new_md()['file_hashes'],
                get_ts())
            self.assertEqual(file_ops.read_meta_data(md_path), get_new_md())


class TestConfirmOverwriteTree(unittest.TestCase):

    def test_no_changes(self):
        for tree in (
                {},
                {
                    'fruit': {
                        'apple': b'different colors',
                        'banana': b'yellow',
                        'tomato': b'red',
                    },
                    'math': b'theorem',
                },
                ):
            with tempfile.TemporaryDirectory() as a:
                create_files(tree, a)
                file_ops.write_meta_data({
                    'id': 'A', 'version_vector': {}, 'file_hashes': {},
                }, os.path.join(a, file_ops.META_FILE))

                with tempfile.TemporaryDirectory() as b:
                    create_files(tree, b)
                    file_ops.write_meta_data({
                        'id': 'B', 'version_vector': {}, 'file_hashes': {},
                    }, os.path.join(b, file_ops.META_FILE))

                    self.assertTrue(file_ops.confirm_overwrite_tree(
                        read_from_ts=file_ops.read_tree_status(a),
                        write_to_ts=file_ops.read_tree_status(b)))

    def test_changes(self):
        read_from_tree = {
            'data': b'alternative',
            'glass': {'watch': b'face', 'window': b'pane'},
            'letter': b'private',
            'new\nline': b'\n',

            'tomato': b'red',

            'Hg': b'mercury',
        }

        write_to_tree = {
            'data': b'original',
            'glass': b'water',
            'letter': {'a': b'alpha', 'b': b'beta'},
            'new\nline': b'\r\n',

            'carrot': b'orange',

            'Hg': b'mercury',
        }

        with tempfile.TemporaryDirectory() as read_from_dir:
            create_files(read_from_tree, read_from_dir)
            file_ops.write_meta_data({
                'id': 'Pen', 'version_vector': {}, 'file_hashes': {},
            }, os.path.join(read_from_dir, file_ops.META_FILE))
            with tempfile.TemporaryDirectory() as write_to_dir:
                create_files(write_to_tree, write_to_dir)
                file_ops.write_meta_data({
                    'id': 'Paper', 'version_vector': {}, 'file_hashes': {},
                }, os.path.join(write_to_dir, file_ops.META_FILE))

                for answer, expected in {
                        '': False, 'n': False, 'x': False, 'Y': False,
                        'y': True,
                }.items():
                    with unittest.mock.patch('builtins.input', spec_set=True,
                            return_value=answer) as input_p:
                        stdout = io.StringIO()
                        with contextlib.redirect_stdout(stdout):
                            result = file_ops.confirm_overwrite_tree(
                                    read_from_ts=file_ops.read_tree_status(
                                        read_from_dir),
                                    write_to_ts=file_ops.read_tree_status(
                                        write_to_dir))
                        self.assertEqual(result, expected)
                        input_p.assert_called_once_with('Change Paper? [y/N] ')
                        self.assertEqual(stdout.getvalue(), '''• Add:
+ "glass/watch"
+ "glass/window"
+ "letter"
+ "tomato"

• Delete:
- "carrot"
- "glass"
- "letter/a"
- "letter/b"

• Overwrite:
≠ "data"
≠ "new\\nline"

''')


class TestOverwriteTree(unittest.TestCase):

    def test_no_changes(self):
        for tree in (
                {},
                {
                    'fruit': {
                        'apple': b'different colors',
                        'banana': b'yellow',
                        'tomato': b'red',
                    },
                    'math': b'theorem',
                },
                ):
            with tempfile.TemporaryDirectory() as a:
                create_files(tree, a)
                hashes = file_ops.hash_file_tree(a)
                file_ops.write_meta_data({
                    'id': 'A', 'version_vector': {}, 'file_hashes': {},
                }, os.path.join(a, file_ops.META_FILE))

                with tempfile.TemporaryDirectory() as b:
                    create_files(tree, b)
                    file_ops.write_meta_data({
                        'id': 'B', 'version_vector': {}, 'file_hashes': {},
                    }, os.path.join(b, file_ops.META_FILE))

                    file_ops.overwrite_tree(
                        read_from_ts=file_ops.read_tree_status(a),
                        write_to_ts=file_ops.read_tree_status(b))

                    for p in a, b:
                        self.assertEqual(file_ops.hash_file_tree(p), hashes)
                    del p

    def test_changes(self):
        read_from_tree = {
            'data': b'alternative',
            'glass': {'watch': b'face', 'window': b'pane'},
            'letter': b'private',

            'tomato': b'red',

            'Hg': b'mercury',
        }

        write_to_tree = {
            'data': b'original',
            'glass': b'water',
            'letter': {'a': b'alpha', 'b': b'beta'},

            'carrot': b'orange',

            'Hg': b'mercury',
        }

        with tempfile.TemporaryDirectory() as read_from_dir:
            create_files(read_from_tree, read_from_dir)
            hashes = file_ops.hash_file_tree(read_from_dir)
            file_ops.write_meta_data({
                'id': 'Pen', 'version_vector': {}, 'file_hashes': {},
            }, os.path.join(read_from_dir, file_ops.META_FILE))
            with tempfile.TemporaryDirectory() as write_to_dir:
                create_files(write_to_tree, write_to_dir)
                file_ops.write_meta_data({
                    'id': 'Paper', 'version_vector': {}, 'file_hashes': {},
                }, os.path.join(write_to_dir, file_ops.META_FILE))

                file_ops.overwrite_tree(
                        read_from_ts=file_ops.read_tree_status(read_from_dir),
                        write_to_ts=file_ops.read_tree_status(write_to_dir))
                for p in read_from_dir, write_to_dir:
                    self.assertEqual(file_ops.hash_file_tree(p), hashes)
                del p


class TestSyncFileTrees(unittest.TestCase):

    def test_same_ids(self):
        md = {'id': 'MyFileTree', 'version_vector': {}, 'file_hashes': {}}
        with tempfile.TemporaryDirectory() as a:
            with tempfile.TemporaryDirectory() as b:
                for parent in a, b:
                    file_ops.write_meta_data(md,
                            os.path.join(parent, file_ops.META_FILE))
                with self.assertRaisesRegex(Exception,
                        '^file trees have the same ID: "MyFileTree"$'):
                    file_ops.sync_file_trees(a, b)

    def test_already_synchronized(self):
        tree = {
                'article': b'news\n',
                'front_page': {
                    'interview': b'dialogue',
                },
        }

        with tempfile.TemporaryDirectory() as a:
            with tempfile.TemporaryDirectory() as b:
                create_files(tree, a)
                create_files(tree, b)

                vv = {'C': 13}
                file_hashes = {
                    'article': hash_bytes(tree['article']),
                    'front_page/interview': hash_bytes(tree['front_page']['interview']),
                }

                file_ops.write_meta_data({
                    'id': 'Apricot',
                    'version_vector': vv,
                    'file_hashes': file_hashes,
                }, os.path.join(a, file_ops.META_FILE))

                file_ops.write_meta_data({
                    'id': 'Berry',
                    'version_vector': vv,
                    'file_hashes': file_hashes,
                }, os.path.join(b, file_ops.META_FILE))

                stdout = io.StringIO()
                with contextlib.redirect_stdout(stdout):
                    file_ops.sync_file_trees(a, b)
                self.assertEqual(stdout.getvalue(),
                        '"Apricot" and "Berry" are already synchronized.\n')

                self.assertEqual(file_ops.read_meta_data(
                    os.path.join(a, file_ops.META_FILE)),
                    {
                        'id': 'Apricot',
                        'version_vector': vv,
                        'file_hashes': file_hashes,
                    })
                self.assertEqual(file_ops.read_meta_data(
                    os.path.join(b, file_ops.META_FILE)),
                    {
                        'id': 'Berry',
                        'version_vector': vv,
                        'file_hashes': file_hashes,
                    })

                for x in a, b:
                    self.assertEqual(file_ops.hash_file_tree(x), file_hashes)
                del x

    def test_same_files_different_metadata(self):
        tree = {
                'article': b'news\n',
                'front_page': {
                    'interview': b'dialogue',
                },
        }

        with tempfile.TemporaryDirectory() as a:
            with tempfile.TemporaryDirectory() as b:
                create_files(tree, a)
                create_files(tree, b)

                file_hashes = {
                    'article': hash_bytes(tree['article']),
                    'front_page/interview': hash_bytes(tree['front_page']['interview']),
                }

                file_ops.write_meta_data({
                    'id': 'Apricot',
                    'version_vector': {'Grapes': 5},
                    'file_hashes': file_hashes,
                }, os.path.join(a, file_ops.META_FILE))

                file_ops.write_meta_data({
                    'id': 'Berry',
                    'version_vector': {'Tomatoes': 2},
                    'file_hashes': {'article': hash_bytes(tree['article'])},
                }, os.path.join(b, file_ops.META_FILE))

                stdout = io.StringIO()
                with contextlib.redirect_stdout(stdout):
                    file_ops.sync_file_trees(a, b)
                self.assertEqual(stdout.getvalue(),
                        'Synchronized "Apricot" and "Berry".\n')

                vv_join = {'Grapes': 5, 'Tomatoes': 2, 'Berry': 1}

                self.assertEqual(file_ops.read_meta_data(
                    os.path.join(a, file_ops.META_FILE)),
                    {
                        'id': 'Apricot',
                        'version_vector': vv_join,
                        'file_hashes': file_hashes,
                    })
                self.assertEqual(file_ops.read_meta_data(
                    os.path.join(b, file_ops.META_FILE)),
                    {
                        'id': 'Berry',
                        'version_vector': vv_join,
                        'file_hashes': file_hashes,
                    })

                for x in a, b:
                    self.assertEqual(file_ops.hash_file_tree(x), file_hashes)
                del x

    def test_user_does_not_confirm_overwriting(self):
        orig_tree = {
            'data': b'original',
            'glass': b'water',
            'letter': {'a': b'alpha', 'b': b'beta'},

            'carrot': b'orange',

            'Hg': b'mercury',
        }

        changed_tree = {
            'data': b'alternative',
            'glass': {'watch': b'face', 'window': b'pane'},
            'letter': b'private',

            'tomato': b'red',

            'Hg': b'mercury',
        }

        version_vector = {'Orig': 2, 'Changed': 4, 'Other': 7}

        def set_up(orig_dir, changed_dir):
            create_files(orig_tree, orig_dir)
            hashes = file_ops.hash_file_tree(orig_dir)
            file_ops.write_meta_data({
                'id': 'Orig',
                'version_vector': version_vector,
                'file_hashes': hashes,
            }, os.path.join(orig_dir, file_ops.META_FILE))

            create_files(changed_tree, changed_dir)
            file_ops.write_meta_data({
                'id': 'Changed',
                'version_vector': version_vector,
                'file_hashes': hashes,
            }, os.path.join(changed_dir, file_ops.META_FILE))

        def check(orig_dir, changed_dir, orig_hashes, changed_hashes):
            changed_vv = versionvectors.advance('Changed', version_vector)

            self.assertEqual(file_ops.read_tree_status(orig_dir), {
                'path': orig_dir,
                'id': 'Orig',
                'pre_vv': version_vector,
                'known_hashes': orig_hashes,
                'disk_hashes': orig_hashes,
                'post_vv': version_vector,
            })
            self.assertEqual(file_ops.read_tree_status(changed_dir), {
                'path': changed_dir,
                'id': 'Changed',
                'pre_vv': version_vector,
                'known_hashes': orig_hashes,
                'disk_hashes': changed_hashes,
                'post_vv': changed_vv,
            })

        def perform_test(*, flip_args):
            with tempfile.TemporaryDirectory() as orig_dir:
                with tempfile.TemporaryDirectory() as changed_dir:
                    set_up(orig_dir, changed_dir)
                    orig_hashes = file_ops.hash_file_tree(orig_dir)
                    changed_hashes = file_ops.hash_file_tree(changed_dir)
                    with unittest.mock.patch('builtins.input', spec_set=True,
                            return_value='n'):
                        with contextlib.redirect_stdout(io.StringIO()):
                            args = (orig_dir, changed_dir)
                            if flip_args:
                                args = reversed(args)
                            with self.assertRaisesRegex(Exception,
                                    '^canceled by the user$'):
                                file_ops.sync_file_trees(*args)
                    check(orig_dir, changed_dir, orig_hashes, changed_hashes)

        for flip in False, True:
            perform_test(flip_args=flip)
        del flip

    def test_sync_changes(self):
        orig_tree = {
            'data': b'original',
            'glass': b'water',
            'letter': {'a': b'alpha', 'b': b'beta'},

            'carrot': b'orange',

            'Hg': b'mercury',
        }

        changed_tree = {
            'data': b'alternative',
            'glass': {'watch': b'face', 'window': b'pane'},
            'letter': b'private',

            'tomato': b'red',

            'Hg': b'mercury',
        }

        version_vector = {'Orig': 2, 'Changed': 4, 'Other': 7}

        def set_up(orig_dir, changed_dir):
            create_files(orig_tree, orig_dir)
            hashes = file_ops.hash_file_tree(orig_dir)
            file_ops.write_meta_data({
                'id': 'Orig',
                'version_vector': version_vector,
                'file_hashes': hashes,
            }, os.path.join(orig_dir, file_ops.META_FILE))

            create_files(changed_tree, changed_dir)
            file_ops.write_meta_data({
                'id': 'Changed',
                'version_vector': version_vector,
                'file_hashes': hashes,
            }, os.path.join(changed_dir, file_ops.META_FILE))

        def check(orig_dir, changed_dir, want_hashes):
            vv = versionvectors.advance('Changed', version_vector)

            self.assertEqual(file_ops.read_tree_status(orig_dir), {
                'path': orig_dir,
                'id': 'Orig',
                'pre_vv': vv,
                'known_hashes': want_hashes,
                'disk_hashes': want_hashes,
                'post_vv': vv,
            })
            self.assertEqual(file_ops.read_tree_status(changed_dir), {
                'path': changed_dir,
                'id': 'Changed',
                'pre_vv': vv,
                'known_hashes': want_hashes,
                'disk_hashes': want_hashes,
                'post_vv': vv,
            })

        def perform_test(*, flip_args):
            with tempfile.TemporaryDirectory() as orig_dir:
                with tempfile.TemporaryDirectory() as changed_dir:
                    set_up(orig_dir, changed_dir)
                    want_hashes = file_ops.hash_file_tree(changed_dir)
                    with unittest.mock.patch('builtins.input', spec_set=True,
                            return_value='y'):
                        with contextlib.redirect_stdout(io.StringIO()):
                            args = (orig_dir, changed_dir)
                            if flip_args:
                                args = reversed(args)
                            file_ops.sync_file_trees(*args)
                    check(orig_dir, changed_dir, want_hashes)

        for flip in False, True:
            perform_test(flip_args=flip)
        del flip

    def test_sync_new_to_old(self):
        old_tree = {
            'data': b'old',
            'glass': b'water',
            'letter': {'a': b'alpha', 'b': b'beta'},

            'carrot': b'orange',

            'Hg': b'mercury',
        }

        new_tree = {
            'data': b'new',
            'glass': {'watch': b'face', 'window': b'pane'},
            'letter': b'private',

            'tomato': b'red',

            'Hg': b'mercury',
        }

        old_vv = {'Alpha': 3, 'Delta': 7}
        new_vv = {'Alpha': 3, 'Delta': 9}

        def set_up(old_dir, new_dir):
            create_files(old_tree, old_dir)
            file_ops.write_meta_data({
                'id': 'Old',
                'version_vector': old_vv,
                'file_hashes': file_ops.hash_file_tree(old_dir),
            }, os.path.join(old_dir, file_ops.META_FILE))

            create_files(new_tree, new_dir)
            file_ops.write_meta_data({
                'id': 'New',
                'version_vector': new_vv,
                'file_hashes': file_ops.hash_file_tree(new_dir),
            }, os.path.join(new_dir, file_ops.META_FILE))

        def check(old_dir, new_dir, want_hashes):
            self.assertEqual(file_ops.read_tree_status(old_dir), {
                'path': old_dir,
                'id': 'Old',
                'pre_vv': new_vv,
                'known_hashes': want_hashes,
                'disk_hashes': want_hashes,
                'post_vv': new_vv,
            })
            self.assertEqual(file_ops.read_tree_status(new_dir), {
                'path': new_dir,
                'id': 'New',
                'pre_vv': new_vv,
                'known_hashes': want_hashes,
                'disk_hashes': want_hashes,
                'post_vv': new_vv,
            })

        def perform_test(*, flip_args):
            with tempfile.TemporaryDirectory() as old_dir:
                with tempfile.TemporaryDirectory() as new_dir:
                    set_up(old_dir, new_dir)
                    want_hashes = file_ops.hash_file_tree(new_dir)
                    with unittest.mock.patch('builtins.input', spec_set=True,
                            return_value='y'):
                        with contextlib.redirect_stdout(io.StringIO()):
                            args = (old_dir, new_dir)
                            if flip_args:
                                args = reversed(args)
                            file_ops.sync_file_trees(*args)
                    check(old_dir, new_dir, want_hashes)

        for flip in False, True:
            perform_test(flip_args=flip)
        del flip

    def test_diverged(self):
        with tempfile.TemporaryDirectory() as a:
            # ‘a’ has no local changes
            create_files({'todo': b'tasks'}, a)
            file_ops.write_meta_data({
                'id': 'Almond',
                'version_vector': {'Almond': 3, 'Berry': 5},
                'file_hashes': file_ops.hash_file_tree(a),
            }, os.path.join(a, file_ops.META_FILE))

            with tempfile.TemporaryDirectory() as b:
                # ‘b’ starts behind ‘a’ and diverges by having local changes.
                create_files({'shopping': b'items'}, b)
                file_ops.write_meta_data({
                    'id': 'Berry',
                    'version_vector': {'Almond': 2, 'Berry': 5},
                    'file_hashes': {'other': hash_bytes(b'state')},
                }, os.path.join(b, file_ops.META_FILE))

                with self.assertRaisesRegex(Exception,
                        '^"Almond" and "Berry" have diverged,'
                        + ' reconcile their files first$'):
                    file_ops.sync_file_trees(a, b)
