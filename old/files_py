import json
import shutil


def write_meta_data(meta_data, directory, *, overwrite):
    """
    Write meta_data to META_FILE in directory.

    Fails for invalid meta data:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     write_meta_data({'replicaID': '', 'treeHash': {}}, d,
    ...         overwrite=True)
    Traceback (most recent call last):
    ValueError: invalid meta data keys

    >>> def make_md():
    ...     return {
    ...         'replicaID': 'Backup',
    ...         'versionVector': {'Laptop': 3, 'Backup': 2},
    ...         'hashTree': {
    ...             'school/homework': hash_bytes('essay'.encode('utf-8')),
    ...             'diary/January': hash_bytes('Vector-Sync'.encode('utf-8')),
    ...         },
    ...     }

    >>> def make_md_2():
    ...     return {
    ...         'replicaID': 'Alternative',
    ...         'versionVector': {'Desktop': 5},
    ...         'hashTree': {
    ...             'book': hash_bytes('text'.encode('utf-8')),
    ...         },
    ...     }

    >>> make_md() == make_md()
    True
    >>> make_md() is make_md()
    False

    >>> make_md_2() == make_md_2()
    True
    >>> make_md_2() is make_md_2()
    False

    >>> make_md() == make_md_2()
    False

    Throws an exception if the directory does not exist:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     write_meta_data(make_md(), os.path.join(d, 'child'),
    ...         overwrite=True)
    ... # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    FileNotFoundError

    Throws an exception if called for a file:
    >>> with tempfile.NamedTemporaryFile() as f:
    ...     write_meta_data(make_md(), f.name, overwrite=True)
    ... # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    NotADirectoryError

    Creates a new META_FILE in directory:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     write_meta_data(make_md(), d, overwrite=False)
    ...     with open(os.path.join(d, META_FILE), 'r', encoding='utf-8') as f:
    ...         json.load(f) == make_md()
    True

    Does not overwrite META_FILE with overwrite=False:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     write_meta_data(make_md(), d, overwrite=False)
    ...     try:
    ...         write_meta_data(make_md_2(), d, overwrite=False)
    ...     except FileExistsError:
    ...         print('caught FileExistsError')
    ...     with open(os.path.join(d, META_FILE), 'r', encoding='utf-8') as f:
    ...         json.load(f) == make_md()
    caught FileExistsError
    True

    Overwrites META_FILE with overwrite=True:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     write_meta_data(make_md(), d, overwrite=False)
    ...     with open(os.path.join(d, META_FILE), 'r', encoding='utf-8') as f:
    ...         json.load(f) == make_md()
    ...     write_meta_data(make_md_2(), d, overwrite=True)
    ...     with open(os.path.join(d, META_FILE), 'r', encoding='utf-8') as f:
    ...         json.load(f) == make_md_2()
    True
    True
    """
    check_meta_data(meta_data)
    meta_file_path = os.path.join(directory, META_FILE)
    mode = 'w' if overwrite else 'x'
    with open(meta_file_path, mode, encoding='utf-8') as f:
        json.dump(meta_data, f, indent=2, sort_keys=True)


def read_meta_data(directory):
    """
    Read meta data from META_FILE in directory.

    Throws an exception if the directory does not exist:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     read_meta_data(os.path.join(d, 'child'))
    ... # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    FileNotFoundError

    Throws an exception if called for a file:
    >>> with tempfile.NamedTemporaryFile() as f:
    ...     read_meta_data(f.name) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    NotADirectoryError

    Throws an exception if META_FILE is missing:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     read_meta_data(d)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    FileNotFoundError

    Throws an exception if the meta data is not valid:
    >>> partial_data = {'replicaID': 'R', 'versionVector': {'R': 1}}
    >>> with tempfile.TemporaryDirectory() as d:
    ...     with open(os.path.join(d, META_FILE), 'w', encoding='utf-8') as f:
    ...         json.dump(partial_data, f)
    ...     read_meta_data(d)
    Traceback (most recent call last):
    ValueError: invalid meta data keys

    >>> def make_md():
    ...     return {
    ...         'replicaID': 'Backup',
    ...         'versionVector': {'Laptop': 3, 'Backup': 2},
    ...         'hashTree': {
    ...             'school/project': hash_bytes('essay'.encode('utf-8')),
    ...             'diary/March': hash_bytes('Vector-Sync!'.encode('utf-8')),
    ...         },
    ...     }

    >>> make_md() == make_md()
    True
    >>> make_md() is make_md()
    False

    Loads an existing META_FILE:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     write_meta_data(make_md(), d, overwrite=False)
    ...     read_meta_data(d) == make_md()
    True
    """
    with open(os.path.join(directory, META_FILE), 'r', encoding='utf-8') as f:
        meta_data = json.load(f)
    check_meta_data(meta_data)
    return meta_data


def delete_up(filepath):
    """
    Delete the file at path then, recursively, empty parent directories.

    Throws an error if path does not exist:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     delete_up(os.path.join(d, 'child'))
    ... # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    FileNotFoundError

    Throws an error if called on a directory:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     e = os.path.join(d, 'e')
    ...     os.mkdir(e)
    ...     delete_up(e)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    IsADirectoryError

    Does not remove the parent dir if it contains other files:
    >>> with tempfile.TemporaryDirectory() as a:
    ...     parent = os.path.join(a, 'b', 'c')
    ...     os.makedirs(parent)
    ...     with open(os.path.join(parent, 'x'), mode='x') as f:
    ...         pass
    ...     with open(os.path.join(parent, 'y'), mode='x') as f:
    ...         pass
    ...     delete_up(os.path.join(parent, 'x'))
    ...     os.path.exists(os.path.join(parent, 'x'))
    ...     os.path.exists(os.path.join(parent, 'y'))
    False
    True

    Removes empty immediate ancestors up to a non-empty ancestor:
    >>> with tempfile.TemporaryDirectory() as a:
    ...     with open(os.path.join(a, META_FILE), mode='x') as f:
    ...         pass
    ...     parent = os.path.join(a, 'c', 'd')
    ...     os.makedirs(parent)
    ...     child = os.path.join(parent, 'e')
    ...     with open(child, mode='x') as f:
    ...         pass
    ...     sorted(os.listdir(a))
    ...     delete_up(child)
    ...     os.listdir(a)
    ['.vector-sync', 'c']
    ['.vector-sync']
    """
    path = os.path.realpath(filepath)
    del filepath

    os.remove(path)
    parent = os.path.dirname(path)
    if parent and not os.listdir(parent):
        os.removedirs(parent)


def copy_down(src, dest):
    """
    Copy file src to dest, creating dest's parent if it does not exist.

    Copies a file to an existing directory:
    >>> with tempfile.TemporaryDirectory() as a:
    ...     with tempfile.TemporaryDirectory() as b:
    ...         x_path, y_path = os.path.join(a, 'x'), os.path.join(b, 'y')
    ...         msg = 's3cret'
    ...         with open(x_path, 'x', encoding='utf-8') as f:
    ...             f.write(msg) and None
    ...         copy_down(x_path, y_path)
    ...         with open(y_path, encoding='utf-8') as f:
    ...             f.read() == msg
    True

    Creates the new directory and its parents and copies the file to it:
    >>> with tempfile.TemporaryDirectory() as a:
    ...     with tempfile.TemporaryDirectory() as m:
    ...         x_path = os.path.join(a, 'x')
    ...         y_path = os.path.join(m, 'n', 'o', 'y')
    ...         msg = 'nest in nest'
    ...         with open(x_path, 'x', encoding='utf-8') as f:
    ...             f.write(msg) and None
    ...         copy_down(x_path, y_path)
    ...         with open(y_path, encoding='utf-8') as f:
    ...             f.read() == msg
    True

    Overwrites an existing file:
    >>> with tempfile.TemporaryDirectory() as d:
    ...     x_path, y_path = os.path.join(d, 'x'), os.path.join(d, 'y')
    ...     x_msg, y_msg = 'hello', 'goodbye'
    ...     with open(x_path, 'x', encoding='utf-8') as f:
    ...         f.write(x_msg) and None
    ...     with open(y_path, 'x', encoding='utf-8') as f:
    ...         f.write(y_msg) and None
    ...     with open(y_path, encoding='utf-8') as f:
    ...         f.read()
    ...     copy_down(x_path, y_path)
    ...     with open(y_path, encoding='utf-8') as f:
    ...         f.read()
    'goodbye'
    'hello'
    """
    parent = os.path.dirname(dest)
    if parent:
        os.makedirs(parent, exist_ok=True)
    shutil.copyfile(src, dest)


def check_tree_change(tree_change):
    """
    Raises ValueError if tree_change is not a tree change.

    Fails if not dict:
    >>> check_tree_change(set())
    Traceback (most recent call last):
    ValueError: tree change is not dict
    >>> check_tree_change(None)
    Traceback (most recent call last):
    ValueError: tree change is not dict

    Fails if dict keys aren't exactly the expected ones:
    >>> check_tree_change({})
    Traceback (most recent call last):
    ValueError: invalid tree change keys
    >>> check_tree_change({'delete': set()})
    Traceback (most recent call last):
    ValueError: invalid tree change keys
    >>> check_tree_change({'delete': set(), 'copy': set(), 'extraKey': set()})
    Traceback (most recent call last):
    ValueError: invalid tree change keys
    >>> check_tree_change({'delete': set(), 'Copy': set()})
    Traceback (most recent call last):
    ValueError: invalid tree change keys

    Fails if a value is not a set:
    >>> check_tree_change({'delete': set(), 'copy': dict()})
    Traceback (most recent call last):
    ValueError: tree change files are not a set

    Fails if a value contains a non-str element:
    >>> check_tree_change({'delete': set(), 'copy': {'a', 24, 'z'}})
    Traceback (most recent call last):
    ValueError: tree change file is not str

    Accepts a valid tree change:
    >>> check_tree_change({'delete': set(), 'copy': set()})
    >>> check_tree_change({'delete': {'list'}, 'copy': {'lecture', 'notes'}})
    """
    if type(tree_change) is not dict:
        raise ValueError('tree change is not dict')
    if set(tree_change.keys()) != {'delete', 'copy'}:
        raise ValueError('invalid tree change keys')
    if any(type(v) is not set for v in tree_change.values()):
        raise ValueError('tree change files are not a set')
    if any(type(f) is not str for v in tree_change.values() for f in v):
        raise ValueError('tree change file is not str')


def get_tree_change(start, end):
    """
    Compute the files to be deleted and copied to transform start into end.

    >>> tc = get_tree_change({}, {'a': hash_bytes(b''), 'x': hash_bytes(b'X')})
    >>> tc == {'delete': set(), 'copy': {'a', 'x'}}
    True

    >>> tc = get_tree_change({'1': hash_bytes(b'1'), '9': hash_bytes(b'0')},
    ...     {})
    >>> tc == {'delete': {'1', '9'}, 'copy': set()}
    True

    >>> tc = get_tree_change({
    ...     'task': hash_bytes(b'dishes'),
    ...     'v': hash_bytes(b'1'),
    ...     'trash': hash_bytes(b't'),
    ...     'bin': hash_bytes(b'b'),
    ...     'i': hash_bytes(b''),
    ... }, {
    ...     'task': hash_bytes(b'laundry'),
    ...     'v': hash_bytes(b'2'),
    ...     'prj': hash_bytes(b''),
    ...     'w': hash_bytes(b''),
    ...     'i': hash_bytes(b''),
    ... })
    >>> tc == {'delete': {'trash', 'bin'}, 'copy': {'task', 'v', 'prj', 'w'}}
    True
    """
    for ht in (start, end):
        check_hash_tree(ht)
    del ht

    tree_change = {
        'delete': {f for f in start if f not in end},
        'copy': {f for f in end if f not in start or start[f] != end[f]},
    }
    check_tree_change(tree_change)
    return tree_change


def confirm_tree_change(tree_change, replica_id):
    """
    Ask the user to confirm (if the change is not empty) and return bool.

    Returns True without asking the user if the change is empty.

    Fails if replica_id is not str:
    >>> confirm_tree_change({'delete': set(), 'copy': set()}, None)
    Traceback (most recent call last):
    ValueError: replica_id is not str
    """
    check_tree_change(tree_change)
    if type(replica_id) is not str:
        raise ValueError('replica_id is not str')

    found = False
    for pathset, title, char in (
            (tree_change['delete'], 'Delete',   '-'),
            (tree_change['copy'],   'Copy',     '+'),
            ):
        if not pathset:
            continue
        found = True
        print(f'â€¢ {title}:')
        for path in sorted(pathset):
            print(char, path)
        print()

    if not found:
        return True

    return input('Change ' + replica_id + '? [y/N] ') == 'y'


def apply_tree_change(tree_change, *, src, dest):
    """Apply tree_change to dest, reading files from src."""
    check_tree_change(tree_change)
    for path in tree_change['delete']:
        delete_up(os.path.join(dest, path))
    for path in tree_change['copy']:
        copy_down(os.path.join(src, path), os.path.join(dest, path))
