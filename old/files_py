

class TreeChange:
    """
    Describes which paths must be changed in a tree to arrive at another.

    Does not accept positional args:
    >>> TreeChange(set(), set(), set())
    Traceback (most recent call last):
    TypeError: __init__() takes 1 positional argument but 4 were given

    Does not accept positional args in addition to the keyword args:
    >>> TreeChange(set(), delete=set(), overwrite=set(), add=set())
    Traceback (most recent call last):
    TypeError: __init__() takes 1 positional argument but 2 positional arguments (and 3 keyword-only arguments) were given

    Does not accept additional keyword args:
    >>> TreeChange(delete=set(), overwrite=set(), add=set(), myarg=set())
    Traceback (most recent call last):
    TypeError: __init__() got an unexpected keyword argument 'myarg'

    Raises an exception if any item is not a set or any elment is not a str:
    >>> TreeChange(delete=[], overwrite=set(), add=set())
    Traceback (most recent call last):
    ValueError: not a set
    >>> TreeChange(delete=set(), overwrite=None, add=set())
    Traceback (most recent call last):
    ValueError: not a set
    >>> TreeChange(delete=set(), overwrite=set(), add=())
    Traceback (most recent call last):
    ValueError: not a set
    >>> TreeChange(delete={'a', 3}, overwrite=set(), add=set())
    Traceback (most recent call last):
    ValueError: not a str
    >>> TreeChange(delete=set(), overwrite={'x', None}, add=set())
    Traceback (most recent call last):
    ValueError: not a str
    >>> TreeChange(delete=set(), overwrite=set(), add={'a', 'b', 1, 'c'})
    Traceback (most recent call last):
    ValueError: not a str

    Accepts empty sets:
    >>> tc = TreeChange(delete=set(), overwrite=set(), add=set())
    >>> (tc.delete, tc.overwrite, tc.add) == (set(), set(), set())
    True

    Accepts sets of strings:
    >>> tc = TreeChange(delete={'bin'}, overwrite={'change', 'me'},
    ...     add={'create', 'this'})
    >>> (tc.delete, tc.overwrite, tc.add) == ({'bin'}, {'change', 'me'},
    ...     {'create', 'this'})
    True

    Implements comparison: == and !=
    >>> TreeChange(delete={'del'}, overwrite={'changed'},
    ...     add={'add', 'me'}) == TreeChange(delete={'del'},
    ...     overwrite={'changed'}, add={'add', 'me'})
    True
    >>> TreeChange(delete={'del'}, overwrite={'changed'},
    ...     add={'add', 'me'}) != TreeChange(delete={'del'},
    ...     overwrite={'changed'}, add={'add', 'me'})
    False
    >>> TreeChange(delete={'a'}, overwrite=set(), add=set()) == TreeChange(
    ...     delete={'b'}, overwrite=set(), add=set())
    False
    >>> TreeChange(delete={'a'}, overwrite=set(), add=set()) != TreeChange(
    ...     delete={'b'}, overwrite=set(), add=set())
    True
    """

    def __init__(self, *, delete, overwrite, add):
        for xs in (delete, overwrite, add):
            if type(xs) is not set:
                raise ValueError('not a set')
            if any(type(x) is not str for x in xs):
                raise ValueError('not a str')

        self.delete, self.overwrite, self.add = delete, overwrite, add

    def __eq__(self, other):
        def extract(tc):
            return tc.delete, tc.overwrite, tc.add
        return extract(self) == extract(other)


def getTreeChange(start, end):
    """
    Compute the TreeChange between the two trees.

    >>> tc = getTreeChange({},
    ...     {'a': hashBytes(b''), 'x': hashBytes(b'X')})
    >>> (tc.delete, tc.overwrite, tc.add) == (set(), set(), {'a', 'x'})
    True

    >>> tc = getTreeChange({'1': hashBytes(b'1'), '9': hashBytes(b'0')},
    ...     {})
    >>> (tc.delete, tc.overwrite, tc.add) == ({'1', '9'}, set(), set())
    True

    >>> tc = getTreeChange({'task': hashBytes(b'dishes'),
    ...     'v': hashBytes(b'1'), 'trash': hashBytes(b't'),
    ...     'bin': hashBytes(b'b'), 'i': hashBytes(b'')},
    ...     {'task': hashBytes(b'laundry'), 'v': hashBytes(b'2'),
    ...     'prj': hashBytes(b''), 'w': hashBytes(b''),
    ...     'i': hashBytes(b'')})
    >>> (tc.delete, tc.overwrite, tc.add) == ({'trash', 'bin'}, {'task', 'v'},
    ...     {'prj', 'w'})
    True
    """
    for th in (start, end):
        checkTreeHash(th)

    delete = {k for k in start if k not in end}
    overwrite = {k for k in start if k in end and start[k] != end[k]}
    add = {k for k in end if k not in start}

    return TreeChange(delete=delete, overwrite=overwrite, add=add)


def confirmTreeChange(treeChange, replicaID):
    """
    Ask the user to confirm the change and return bool.

    Returns True without asking for confirmation if the change is empty.
    """
    found = False
    for pathSet, title, char in (
            (treeChange.add,        'New',      '+'),
            (treeChange.delete,     'Deleted',  '−'),
            (treeChange.overwrite,  'Changed',  '≠'),
            ):
        if not pathSet:
            continue
        found = True
        print('•', title, 'files:')
        for path in sorted(pathSet):
            print(char, path)
        print()

    if not found:
        return True

    return input('Make changes to ' + replicaID + '? [y/N] ').upper() == 'Y'


def applyTreeChange(treeChange, *, src, dest):
    """
    Apply the TreeChange to dest, reading files from src.

    It does not accept additional positional arguments:
    >>> applyTreeChange(TreeChange(delete=set(), overwrite=set(), add=set()),
    ...     None, src='s', dest='d')
    Traceback (most recent call last):
    TypeError: applyTreeChange() takes 1 positional argument but 2 positional arguments (and 2 keyword-only arguments) were given
    """
    for path in treeChange.delete:
        delete_up(os.path.join(dest, path))
    for items in (treeChange.overwrite, treeChange.add):
        for path in items:
            copy_down(os.path.join(src, path), os.path.join(dest, path))
